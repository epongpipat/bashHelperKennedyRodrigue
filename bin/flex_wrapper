#!/bin/bash

# ------------------------------------------------------------------------------
# usage
# ------------------------------------------------------------------------------
usage() {
    cat <<USAGE
    
    Usage: $0 [options]

    Options:
        
        --in-scripts, --in_scripts <path>       (required)
            path to text file of scripts to wrap
                inside the text file has a new line for each script to run
        
        --in-ids, --in_ids <path>               (required)
            path to csv with subject and session list
                columns: sub, ses, (airc_id)

        --scripts-idx, --scripts_idx            (required)
            script to process:
                <int1>,<int2>,...       multiple inputs separated by commas (e.g., -s 1,2,3)
                <int_start>:<int_end>   range of scripts to process (e.g., -s 1:3)
                'all'                   process all scripts

        --ids-idx, --ids_idx                     (required)
            idx of ids to process:
                <int1>,<int2>,...       multiple inputs separated by commas (e.g., -s 1,2,3)
                <int_start>:<int_end>   range of scripts to process (e.g., -s 1:3)
                'all'                   process all scripts

        --parallel <0|sge|slurm>                 (optional)
            whether to run in parallel
                0       no parallelization, runs serially (default)
                sge     SGE
                slurm   SLURM

        --parallel-opts, --parallel_opts <str>   (optional)
            additional flags/options to pass to parallel engine

        --parallel-job-limit, --parallel_job_limit <int>   (optional)
            maximum number of jobs to running on SGE (default: 0, i.e. no limit)

        --sge-server, --sge_server <0|1|2>       (optional)
            which SGE server to use
                0. both (defult)
                1. ponyo
                2. totoro

        --print <0|1>                            (optional)
            print commands to screen only (default: 0)

        --overwrite <0|1>                        (optional)
            flag to overwrite existing output files (default: 0)

        -h, --help
            show this help message and exit

USAGE
}

usage_scripts_idx() {
    usage_scripts_idx="\n\tscripts:\n"
    in_scripts=(`cat ${in_scripts}`)
    for i in ${!in_scripts[@]}; do
        c=`echo ${i} + 1 | bc`
        usage_scripts_idx="${usage_scripts_idx}\t\t${c}:\t${in_scripts[$i]}\n"
    done
    echo -e ${usage_scripts_idx}
}

usage_ids_idx() {
    usage_ids_idx="\n\tids_idx:\n"
    ids=(`cat ${in_ids}`)
    # remove header
    ids_all=("${ids[@]:1}")
    for i in ${!ids_all[@]}; do
        c=`echo ${i} + 1 | bc`
        usage_ids_idx="${usage_ids_idx}\t\t${c}:\t${ids_all[$i]}\n"
    done
    echo -e ${usage_ids_idx}
}

# ------------------------------------------------------------------------------
# default args
# ------------------------------------------------------------------------------
# ids_idx=1
parallel=0
parallel_job_limit=0
print=0
sge_server=0
test=0
overwrite=0
# set -e
# color_red='\033[0;31m'
# color_yellow='\033[0;33m'
# color_default='\033[0m'

# ------------------------------------------------------------------------------
# parse args
# ------------------------------------------------------------------------------
# if no arguments supplied, show usage
if [ $# -eq 0 ]; then
    usage
    exit 1
fi

# parse command line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --in_scripts|--in-scripts)
            in_scripts=$2
            shift 2
            ;;
        --in_ids|--in-ids)
            in_ids=$2
            shift 2
            ;;
        --scripts_idx|--scripts-idx)
            scripts_idx=$2
            shift 2
            ;;
        --ids_idx|--ids-idx)
            ids_idx=$2
            shift 2
            ;;
        --parallel)
            parallel=$2
            if [[ ${parallel} == "0" ]] || [[ ${parallel} == "sge" ]] || [[ ${parallel} == "slurm" ]]; then
                shift 2
            else
                usage
                # echo -e "${color_red}error${color_default}: --parallel must be 0, sge, or slurm"
                # exit 1
                bash error_msg "--parallel must be 0, sge, or slurm"
            fi
            ;;
        --parallel_opts|--parallel-opts)
            parallel_opts=$2
            shift 2
            ;;
        --parallel_job_limit|--parallel-job-limit)
            parallel_job_limit=$2
            shift 2
            ;;
        --sge_server)
            sge_server=$2
            shift 2
            ;;
        --print)
            print=$2
            shift 2
            ;;
        --overwrite)
            overwrite=$2
            shift 2
            ;;
        -h|--help)
            usage
            exit 1
            ;;
        *)
            usage
            echo "Unknown argument: $1"
            usage
            exit 1
            ;;
    esac
done

# ------------------------------------------------------------------------------
# check args
# ------------------------------------------------------------------------------
if [[ -z ${in_scripts} ]]; then
    usage
    # echo -e "\n${color_red}error${color_default}: must specify --in_scripts"
    # exit 1
    bash error_msg "must specify --in_scripts"
fi

if [[ -z ${in_ids} ]]; then
    usage
    # echo -e "\n${color_red}error${color_default}: must specify --in_ids"
    # exit 1
    bash error_msg "must specify --in_ids"
fi

if [[ -z ${scripts_idx} ]]; then
    usage
    usage_scripts_idx
    # echo -e "\n${color_red}error${color_default}: must specify --scripts_idx\n"
    # exit 1
    bash error_msg "must specify --scripts_idx"
fi

if [[ -z ${ids_idx} ]]; then
    usage
    usage_ids_idx
    # echo -e "\n${color_red}error${color_default}: must specify --ids_idx\n"
    # exit 1
    bash error_msg "must specify --ids_idx"
fi

# ------------------------------------------------------------------------------
# read in_scripts
# ------------------------------------------------------------------------------
check_file_type_crlf ${in_scripts}
in_scripts=(`cat ${in_scripts}`)
if [[ ${#in_scripts[@]} -eq 0 ]]; then
    # echo -e "\n${color_red}error${color_default}: no scripts found in ${in_scripts}"
    # exit 1
    bash error_msg "no scripts found in ${in_scripts}"
fi

if [[ ${scripts_idx} == "all" ]]; then
    scripts_idx=(`seq 1 $((${#in_scripts[@]} - 1))`)
elif [[ ${scripts_idx} == *":"* ]]; then
    scripts_idx_start=`echo ${scripts_idx} | awk -F: '{print $1}'`
    scripts_idx_end=`echo ${scripts_idx} | awk -F: '{print $2}'`
    scripts_idx=(`seq ${scripts_idx_start} ${scripts_idx_end}`)
elif [[ ${scripts_idx} == *","* ]]; then
    scripts_idx=(`echo ${scripts_idx} | sed 's/,/ /g'`)
else
    scripts_idx=(`echo ${scripts_idx}`)
fi

# adjust scripts_idx to 0-based
for i in ${!scripts_idx[@]}; do
    scripts_idx[$i]=`echo ${scripts_idx[$i]} - 1 | bc`
done

# subset
declare -a scripts
for i in ${!scripts_idx[@]}; do
    if [[ ${in_scripts[${scripts_idx[$i]}]} =~ '${root_dir}' ]]; then
	root_dir=`get_root_dir kenrod`
        scripts[$i]=`eval echo ${in_scripts[${scripts_idx[$i]}]}`
    else
        scripts[$i]=${in_scripts[${scripts_idx[$i]}]}
    fi
done

echo -e "\nscripts:"
for i in ${!scripts[@]}; do
    c=`echo ${i} + 1 | bc`
    echo -e "\t${c}:\t${scripts[$i]}"
done

# ------------------------------------------------------------------------------
# read ids
# ------------------------------------------------------------------------------
check_file_type_crlf ${in_ids}
id_cols=(`head -n 1 ${in_ids} | sed 's/,/ /g'`)
id_cols_alt=`head -n 1 ${in_ids}`
# echo ${id_cols[@]}
# exit 1
ids_all=(`cat ${in_ids}`)
# id_cols=(`awk -F ',' '{print $1}' ${in_ids}`)

if [[ ${#in_ids[@]} -eq 0 ]]; then
    # echo -e "\n${color_red}error${color_default}: no ids found in ${in_ids}"
    # exit 1
    bash error_msg "no ids found in ${in_ids}"
fi

if [[ ${ids_idx} == "all" ]]; then
    ids_idx=(`seq 1 $((${#ids_all[@]} - 1))`)
elif [[ ${ids_idx} == *":"* ]]; then
    ids_idx_start=`echo ${ids_idx} | awk -F: '{print $1}'`
    ids_idx_end=`echo ${ids_idx} | awk -F: '{print $2}'`
    ids_idx=(`seq ${ids_idx_start} ${ids_idx_end}`)
elif [[ ${ids_idx} == *","* ]]; then
    ids_idx=(`echo ${ids_idx} | sed 's/,/ /g'`)
else
    ids_idx=(`echo ${ids_idx}`)
fi

# echo -e "\nids_idx: ${ids_idx[@]}"

# subset
declare -a ids
for i in ${!ids_idx[@]}; do
    ids[$i]=${ids_all[${ids_idx[$i]}]}
done

echo -e "\nids:"
for i in ${!ids[@]}; do
    c=`echo ${i} + 1 | bc`
    echo -e "\t${c}:\t${ids[$i]}"
done

# exit 1

# ------------------------------------------------------------------------------
# parallel: 0 (serial)
# ------------------------------------------------------------------------------
if [[ ${parallel} == "0" ]]; then
    echo -e "\nscript_idx,id_idx,${id_cols_alt}"
    for s in ${!scripts[@]}; do
        for i in ${!ids[@]}; do
            id=${ids[$i]}
            s1=`echo ${s} + 1 | bc`
            i1=`echo ${i} + 1 | bc`
            echo -e "\n${s1},${i1},${ids[$i]}"

            # ---
            # flex options
            # not working, but not sure why
            # ---
            # id_i=(`echo ${ids[${i}]} | sed 's/,/ /g'`)
            # opts=""
            # for j in ${!id_cols[@]}; do
            #     opts="${opts}--${id_cols[${j}]} ${id_i[${j}]} "
            # done
            # opts="${opts}--overwrite ${overwrite}"

            # ---
            # fixed options
            # ---
            study=`echo ${id} | awk -F, '{print $1}'`
            airc_id=`echo ${id} | awk -F, '{print $2}'`
            sub=`echo ${id} | awk -F, '{print $3}'`
            ses=`echo ${id} | awk -F, '{print $4}'`
            opts="--study ${study} --airc_id ${airc_id} --sub ${sub} --ses ${ses} --overwrite ${overwrite}"
            
            cmd="bash ${scripts[${s}]} ${opts}"
            echo -e "\ncommand:\n${cmd}\n"
            if [[ ${print} -eq 0 ]]; then
                eval ${cmd}
            fi
        done
    done
fi

# ------------------------------------------------------------------------------
# parallel: sge
# ------------------------------------------------------------------------------
# sge_default_opts="-V \
# -S /bin/bash \
# -o jid-\$JOB_ID-\$TASK_ID_jname-\$JOB_NAME.log \
# -j y \
# -m a \
# -M ${USER}@utdallas.edu"

if [[ ${parallel} == 'sge' ]]; then
    echo -e "\nscript_idx,id_idx,${id_cols_alt}"
    module load sge
    declare -a job_id_list
    c=0
    for s in ${!scripts[@]}; do
        for i in ${!ids[@]}; do
            id=${ids[$i]}
            s1=`echo ${s} + 1 | bc`
            i1=`echo ${i} + 1 | bc`
            echo -e "\n${s1},${i1},${ids[$i]}"
            
            # ---
            # flex options
            # not working, but not sure why
            # ---
            # id_i=(`echo ${ids[$i]} | sed 's/,/ /g'`)
            # opts=""
            # for j in ${!id_cols[@]}; do
            #     opts="${opts}--${id_cols[$j]} ${id_i[$j]} "
            # done
            # opts="${opts}--overwrite ${overwrite}"

            # ---
            # fixed options
            # ---
            study=`echo ${id} | awk -F, '{print $1}'`
            airc_id=`echo ${id} | awk -F, '{print $2}'`
            sub=`echo ${id} | awk -F, '{print $3}'`
            ses=`echo ${id} | awk -F, '{print $4}'`
            opts="--study ${study} --airc_id ${airc_id} --sub ${sub} --ses ${ses} --overwrite ${overwrite}"
            
            script_name=`basename ${scripts[${s}]} | sed 's/.sh//'`
            job_name="sub-${sub}_ses-${ses}_script-${script_name}"
            # job_name="${script_name}"

            job_id_list[${c}]=${job_name}
            
            # sge_opts=""
            sge_opts="-N ${job_name}"

            # sge server
            if [[ ${sge_server} -eq 1 ]]; then
                sge_opts="${sge_opts} -q all.q@cvlkrcompute1.utdallas.edu"
            elif [[ ${sge_server} -eq 2 ]]; then
                sge_opts="${sge_opts} -q all.q@cvlkrcompute2.utdallas.edu"
            fi

            if [[ ! -z ${parallel_opts} ]]; then
                sge_opts="${sge_opts} ${parallel_opts}"
            fi

            # sge job limit
            if [[ ${parallel_job_limit} -gt 0 ]] && [[ ${c} -ge ${parallel_job_limit} ]]; then
                sge_opts="${sge_opts} -hold_jid ${job_id_list[$((c - parallel_job_limit))]}"
            fi

            cmd="qsub ${sge_opts} ${scripts[$s]} ${opts}"
        
            echo -e "command:\n${cmd}"
            if [[ ${print} -eq 0 ]]; then
                eval ${cmd}
            fi

            c=`echo ${c} + 1 | bc`
        done
    done
fi

# ------------------------------------------------------------------------------
# parallel: slurm
# ------------------------------------------------------------------------------
# slurm_opts="--shell=/bin/bash \
# --output=jid-$SLURM_JOB_ID-$SLURM_ARRAY_TASK_ID_jname-$SLURM_JOB_NAME.log \
# --error=jid-$SLURM_JOB_ID-$SLURM_ARRAY_TASK_ID_jname-$SLURM_JOB_NAME.log \
# --mail-type=FAIL \
# --mail-user=${USER}@utdallas.edu"

if [[ ${parallel} == 'slurm' ]]; then
    echo -e "\nscript_idx,id_idx,${id_cols_alt}"
    declare -a job_id_list
    c=0
    for s in ${!scripts[@]}; do
        for i in ${!ids[@]}; do
            id=${ids[$i]}
            s1=`echo ${s} + 1 | bc`
            i1=`echo ${i} + 1 | bc`
            echo -e "\n${s1},${i1},${ids[$i]}"
            
            # ---
            # flex options
            # not working, but not sure why
            # ---
            # id_i=(`echo ${ids[$i]} | sed 's/,/ /g'`)
            # opts=""
            # for j in ${!id_cols[@]}; do
            #     opts="${opts}--${id_cols[$j]} ${id_i[$j]} "
            # done
            # opts="${opts}--overwrite ${overwrite}"

            # ---
            # fixed options
            # ---
            study=`echo ${id} | awk -F, '{print $1}'`
            airc_id=`echo ${id} | awk -F, '{print $2}'`
            sub=`echo ${id} | awk -F, '{print $3}'`
            ses=`echo ${id} | awk -F, '{print $4}'`
            opts="--study ${study} --airc_id ${airc_id} --sub ${sub} --ses ${ses} --overwrite ${overwrite}"
            
            script_name=`basename ${scripts[${s}]} | sed 's/.sh//'`
            job_name="sub-${sub}_ses-${ses}_script-${script_name}"

            job_id_list[${c}]=${job_name}
            
            slurm_opts="--job-name=${job_name}"

            if [[ ! -z ${parallel_opts} ]]; then
                slurm_opts="${slurm_opts} ${parallel_opts}"
            fi

            # sge job limit
            if [[ ${parallel_job_limit} -gt 0 ]] && [[ ${c} -ge ${parallel_job_limit} ]]; then
                slurm_opts="${slurm_opts} --dependency=afternotok:${job_id_list[$((c - parallel_job_limit))]}"
            fi

            cmd="sbatch ${slurm_opts} ${scripts[$s]} ${opts}"
        
            echo -e "command:\n${cmd}"
            if [[ ${print} -eq 0 ]]; then
                eval ${cmd}
            fi

            c=`echo ${c} + 1 | bc`
        done
    done
fi
